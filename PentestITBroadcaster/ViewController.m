//
//  ViewController.m
//  PentestITBroadcaster
//
//  Created by Vladimir Korennoy on 05.04.15.
//  Copyright (c) 2015 PENTESTIT. All rights reserved.
//

#import "ViewController.h"

@implementation ViewController

//@synthesize logArea;
@synthesize textArea;
@synthesize ffmpegPath;
@synthesize audioDevicesList;
@synthesize videoDevicesList;
@synthesize timer;
@synthesize statusSpinner;
@synthesize startBtn;
@synthesize stopBtn;
@synthesize scrSize;
@synthesize fpsNumver;

NSString *constantArgsPlugin = @" -f avfoundation";
NSString *constantArgsVcodec = @" -vcodec libx264";
NSString *constantArgsScreen = @" -s 1280x720";

NSString *theURL = @"rtmp://w1.pentestit.ru/live/1?token=71%7C1%7CIh8VfGRJBl4S4DRlBMd1eyhOEcqaMUETBe2336DY";

NSTask *taskLong;
NSPipe *inputPipe;
NSPipe *outputPipe;



NSString *strCommand = @"ffmpeg -f avfoundation -i \"1:0\" -vcodec libx264 -s 1280x720 -acodec libmp3lame -b:a 64k -threads 4 -r 10 -f flv \"rtmp://w1.pentestit.ru/live/1?token=71%7C1%7CIh8VfGRJBl4S4DRlBMd1eyhOEcqaMUETBe2336DY\"";

- (void)viewDidLoad {
    [super viewDidLoad];

    // Do any additional setup after loading the view.
    self.ffmpegPath = @"/opt/local/bin/ffmpeg";
    [self.videoDevicesList removeAllItems];
    [self.audioDevicesList removeAllItems];
}

- (void)setRepresentedObject:(id)representedObject {
    [super setRepresentedObject:representedObject];

    // Update the view, if already loaded.
}

- (void) deviceList
{
    int pid = [[NSProcessInfo processInfo] processIdentifier];
    
    [self logString:@"Getting device list"];
    
    @try
    {
    
        NSPipe *pipe = [NSPipe pipe];
        NSFileHandle *file = pipe.fileHandleForReading;
        
        NSTask *task = [[NSTask alloc] init];
        
        task.launchPath = self.ffmpegBinPath.stringValue;
        task.arguments = @[@"-f", @"avfoundation", @"-list_devices", @"true", @"-i", @"\"\""];
        
        task.standardOutput = pipe;
        task.standardError = pipe;
        
        [self logString:@"Launching external command for device list..."];
        [task launch];
        
        NSData *data = [file readDataToEndOfFile];
        [file closeFile];
        
        NSString *output = [[NSString alloc] initWithData: data encoding: NSUTF8StringEncoding];
        
        [self logString:@"Parsing device list command output"];
        // split video and audio devices
        NSArray *cmps = [output componentsSeparatedByString:@"AVFoundation audio devices:"];
        
        NSString *audioDevices = [cmps objectAtIndex:1];
        NSString *videoDevices = [cmps objectAtIndex:0];
        
        //parse devices list
        NSMutableArray *vParsed = [self parseDeviceFrom:videoDevices];
        NSMutableArray *aParsed = [self parseDeviceFrom:audioDevices];
        
        // setting UI control lists
        [self.videoDevicesList addItemsWithTitles:vParsed];
        [self.audioDevicesList addItemsWithTitles:aParsed];
        
        id txt = self.textArea.documentView;
        NSAttributedString *str = [[NSAttributedString alloc] initWithString:output];
        
        [[(NSTextView *)txt textStorage] appendAttributedString:str];
    }
    
    @catch (NSException *ex) {
        [self logString:ex.reason];
    }
    
}

/**
 Parses single device line from given text
*/
-(NSMutableArray *) parseDeviceFrom: (NSString *)text {
    [self logString:@"parsing device info"];
    NSString *searchedString = text;
    NSRange   searchedRange = NSMakeRange(0, [searchedString length]);
    NSString *pattern = @"(\\[[0-9]+\\] .*)";
    NSError  *error = nil;
    
    NSRegularExpression* regex = [NSRegularExpression regularExpressionWithPattern: pattern options:0 error:&error];
    NSArray* matches = [regex matchesInString:searchedString options:0 range: searchedRange];

    NSMutableArray *strMatches = [[NSMutableArray alloc] init];
    
    for (NSTextCheckingResult* match in matches) {
        NSRange group1 = [match rangeAtIndex:1];
        [strMatches addObject:[searchedString substringWithRange:group1]];
    }
    
    return strMatches;
}

/**
 Parses single device line from given text
 */
-(NSString *) parseDeviceIndex: (NSString *)text {
    [self logString:@"parsing device index"];
    
    NSString *searchedString = text;
    NSRange   searchedRange = NSMakeRange(0, [searchedString length]);
    NSString *pattern = @"\\[([0-9]+)\\] .*";
    NSError  *error = nil;
    
    NSRegularExpression* regex = [NSRegularExpression regularExpressionWithPattern: pattern options:0 error:&error];
    NSArray* matches = [regex matchesInString:searchedString options:0 range: searchedRange];
    
    NSMutableArray *strMatches = [[NSMutableArray alloc] init];
    NSString *result = [[NSString alloc] init];
    
    for (NSTextCheckingResult* match in matches) {
        NSRange group1 = [match rangeAtIndex:1];
        result = [result stringByAppendingString:[searchedString substringWithRange:group1]];
    }
    
    return result;
}

- (IBAction)broadcastStart:(id)sender
{
    int pid = [[NSProcessInfo processInfo] processIdentifier];
    [[self startBtn] setEnabled:NO];
    [[self stopBtn] setEnabled:YES];
    
    @try {
        
        [self logString:@"Starting broadcast streaming"];
        
        outputPipe = [NSPipe pipe];
        
        taskLong = [[NSTask alloc] init];
        
        //TODO: check path
        taskLong.launchPath = self.ffmpegBinPath.stringValue;
        
        [self logString:[NSString stringWithFormat:@"ffmpeg path: %@", taskLong.launchPath]];
        
        NSMutableArray *args = [[NSMutableArray alloc] init];
        
        [args addObject:@"-f"];
        [args addObject:@"avfoundation"];
        
        // TODO: check arguments
        
        NSString *selectedVideoDevice = [[self.videoDevicesList selectedItem] title];
        NSString *videoIndex = [self parseDeviceIndex:selectedVideoDevice];
        
        NSString *selectedAudioDevice = [[self.audioDevicesList selectedItem] title];
        NSString *audioIndex = [self parseDeviceIndex:selectedAudioDevice];
        
        NSLog(@"Video index is: %@", videoIndex);
        NSLog(@"Audio index is: %@", audioIndex);
        
        [self logString:[NSString stringWithFormat:@"video device index: %@", videoIndex]];
        [self logString:[NSString stringWithFormat:@"audio device index: %@", audioIndex]];
        
        [args addObject:@"-i"];
        [args addObject: [NSString stringWithFormat:@"%@:%@", videoIndex, audioIndex]];
        
        [args addObject:@"-vcodec"];
        [args addObject:@"libx264"];
        
        //[args addObject:@"-s"];
        //NSString *s = [self.scrSize stringValue];
        //[args addObject:s];
        
        [args addObject:@"-acodec"];
        [args addObject:@"libmp3lame"];
        
        [args addObject:@"-b:a"];
        [args addObject:[self.audioBitrate stringValue]];
        
        [args addObject:@"-threads"];
        [args addObject:@"2"];
        
        [args addObject:@"-r"];
        [args addObject:[self.fpsNumver stringValue]];
        
        [args addObject:@"-f"];
        [args addObject:@"flv"];
        
        
        NSString *streamKeyCorrect = [[self.streamKey stringValue] stringByReplacingOccurrencesOfString:@"|" withString:@"%7C"];
        
        NSString *fullUrl = [NSString stringWithFormat:@"%@/%@",[self.fmsUrl stringValue], streamKeyCorrect];
        NSLog(@"FULL streaming URL will be: %@", fullUrl);
        [self logString:[NSString stringWithFormat:@"Full stream url after corrections: %@", fullUrl]];
        
        [args addObject:fullUrl];
        
        [self logString:@"Redirecting output and input to pipes.."];
        
        taskLong.arguments = args;
        taskLong.standardOutput = outputPipe;
        taskLong.standardError = outputPipe;
        inputPipe = [NSPipe pipe];
        taskLong.standardInput = inputPipe;
        
        [taskLong launch];
        [self logString:@"Broadcasting launched.. scheduling a timer to receive output..."];
        
        [self.statusSpinner startAnimation:self];
        [self.statusText setStringValue:@"Started"];

        
        self.timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(startReadingPipe) userInfo:nil repeats:YES];
    }
    @catch(NSException *ex) {
        [self logString:@"Exception occured. Details below"];

        [self logString:ex.reason];
    }

}

-(void) startReadingPipe {
    [self readPipeToTheEnd:nil];
}


-(void) readPipeToTheEnd:(NSTimer *)timer {
    @try {
        NSFileHandle *file = outputPipe.fileHandleForReading;
        NSData *data = [file availableData];
        NSString *output = [[NSString alloc] initWithData: data encoding: NSUTF8StringEncoding];
        
        id txt = self.textArea.documentView;
        NSAttributedString *str = [[NSAttributedString alloc] initWithString:output];
        [self logString:output];
        [[(NSTextView *)txt textStorage] appendAttributedString:str];
        [[self.textArea documentView] scrollToEndOfDocument:nil];
    }
    @catch(NSException *ex) {
        [self logString:ex.reason];
    }
}

- (IBAction)broadcastStop:(id)sender {
    [self logString:@"Sending Q key to gracefully stop FFMPEG streaming..."];
    
    @try {
        NSString *qData = @"q";
        [[inputPipe fileHandleForWriting] writeData:[qData dataUsingEncoding:[NSString defaultCStringEncoding]]];
        [self.timer invalidate];
        [self.statusSpinner stopAnimation:self];
        [self.statusText setStringValue:@"Stopped"];
    }
    @catch (NSException *ex) {
        [self logString:ex.reason];
    }
    
}


- (IBAction)startBtnPressed:(id)sender {
    [self deviceList];
}
- (IBAction)stopBtnPressed:(id)sender {
    //[self getFfmpegLocation];
}

-(void) logString: (NSString *)text {
    
    NSString *datetime = [NSDateFormatter localizedStringFromDate:[NSDate date] dateStyle:NSDateFormatterShortStyle timeStyle:NSDateFormatterFullStyle];
    
    NSString *fullStr = [NSString stringWithFormat:@"[%@] %@\n", datetime, text];
    
    NSData *data = [fullStr dataUsingEncoding:NSUTF8StringEncoding];
    
    NSString *appDocDirectory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
    
    NSString *finalPath = [appDocDirectory stringByAppendingPathComponent:@"ppt_broadcast_event.log"];
    
    NSFileHandle *outFile = [NSFileHandle fileHandleForWritingAtPath:finalPath];
    
    if(outFile == nil) {
        [[NSFileManager defaultManager] createFileAtPath:finalPath contents:nil attributes:nil];
        outFile = [NSFileHandle fileHandleForWritingAtPath:finalPath];
    }
    
    [outFile seekToEndOfFile];
    [outFile writeData:data];
    [outFile closeFile];
}



@end
